# Deobfuscation

**Note that the payload and loader were from different copies of bbystealer and use different endpoints**

- `*_original.js` contains the original source.
- `*_beautified.js` is the original code formatted, but otherwise unchanged.
- `*_deobfuscated.js` is fully deobfuscated code.

## Extracting obfuscated JavaScript

### loader

All the JavaScript used in the nexe executable is stored as plaintext within the exe itself.
This includes the loader, which is stored as a single line of obfuscated JavaScript.

The loader code can be found near the bottom of the executable, but before debugging dependencies if present.
It can be easily found in mose cases by searching for keywords found in the loader source code, such as "Discord".

To extract the loader, you copy the code as-is from the exe.
Take care to make sure no extra opening braces are included.

For example, the loader for the `OwOGame.exe` file can be found at line 889028.
It contains an opening brace at the end of the line, which should not be included when extracted.

### payload

The payload can be downloaded from the link found in the loader after deobfuscating it.
This link looks something like `https://indianboatparty[.]com/OOJfZ9s6pHbF/str`.

Alternatively, if the exe is run with a Discord installation present, the payload will be written to:

```js
process.env.LOCALAPPDATA + '\\*cord*\\app-*\\modules\\discord_desktop_core-*\\discord_desktop_core\\index.js'
```

## Formatting and initial deobfuscation

Both the loader and the payload can be formatted and partially deobfuscated using tools such as:

- [d4js](https://lelinhtinh.github.io/de4js/)
- [Online JavaScript Beautifier](https://beautifier.io/)

This makes the code more readable and can simplify some expressions.
For example:

```js
function onlyUnique(_0x25228c,_0x4dd03b,_0x115be5){const _0x4d4641={};_0x4d4641['gvSQz']=function(_0x4e9814,_0xe10a5a){return _0x4e9814===_0xe10a5a;};function _0x1c86f9(_0x8c86ab,_0x1044df,_0x6259b,_0x55e03d){return a0_0x5ce233(_0x8c86ab,_0x1044df-0x14f,_0x6259b-0x136,_0x55e03d- -0x648);}const _0x5f07df=_0x4d4641;return _0x5f07df[_0x1c86f9('hw71',0x40d,0x28c,0x1cd)](_0x115be5['index'+'Of'](_0x25228c),_0x4dd03b);}
```

becomes:

```js

function onlyUnique(_0x25228c, _0x4dd03b, _0x115be5) {
    const _0x4d4641 = {};
    _0x4d4641['gvSQz'] = function (_0x4e9814, _0xe10a5a) {
        return _0x4e9814 === _0xe10a5a;
    };

    function _0x1c86f9(_0x8c86ab, _0x1044df, _0x6259b, _0x55e03d) {
        return a0_0x5ce233(_0x8c86ab, _0x1044df - 0x14f, _0x6259b - 0x136, _0x55e03d - -0x648);
    }
    const _0x5f07df = _0x4d4641;
    return _0x5f07df[_0x1c86f9('hw71', 0x40d, 0x28c, 0x1cd)](_0x115be5['index' + 'Of'](_0x25228c), _0x4dd03b);
}
```

Furthermore, one obfuscation technique used splits strings into multiple parts.
d4js can be used to reverse this process, such that expressions such as `'crypt' + 'o'` becomes `'crypto'`.

From here, we can see the names and some information about global functions and variables.
The settings used to obfuscate this code did not allow these to be renamed.
This is an oversight as none of these are exported.
Enabling this would have made the code more difficult to analyse without changing its functionality.

Some other global functions are present, as well as some nested functions and constants.
These are used to further obfuscate strings, members of objects, and basic operations.
For example:

```js
_0x31dfad[_0x4f879f('myG#', 0x802, 0x6a1, 0x696)]
```

becomes

```js
'https://indianboatparty.com/OOJfZ9s6pHbF/tokens'
```

Note that, once formatted, the code will no longer run.
If we try to run it at this stage, the V8 runtime will exceed its memory limit and crash.
This is because of self defending which is discussed in the next section.

## Defeating self defending

The reason for the crash when running beautified code is that some functions perform a regex search on their own source code.
This process succeedes in the function's original form, but fails when beautified.

For example, the `a0_0x440f` function is used in string obfuscation and implements this technique for self defending.
The function cannot be run without changes if it is beautified.

To defeat self defending, we can simply extract these functions in their original form without formatting.
These functions will not be present in the deobfuscated code, so this is only necessary for the deobfuscation script.

## Deobfuscating strings and members

Most strings are obfuscated by splitting them into multiple parts and replacing them with equivalent expressions using the functions mentioned above.

To deobfuscate these strings, the obfuscating functions should be loaded into a deobfuscation script.
This can be scoped appropriately so that the script only uses functions that would be available to the program.
However, this was not necessary as there were no conflicts between functions at different scopes.

```js
_0x2b801e[_0x74a69e(0xacc, 0xb2c, 0x92e, 'OBiu') + 'ch'](_0x4c5ebd => _0x383f59['push'](_0x4c5ebd))
```

becomes

```js
_0x2b801e['forEach'](_0x4c5ebd => _0x383f59['push'](_0x4c5ebd))
```

Notice that methods have also been obfuscated here.
The above code can be further simplified as follows:

```js
_0x2b801e.forEach(_0x4c5ebd => _0x383f59.push(_0x4c5ebd))
```

## Deobfuscating function calls and operations

## Fixing control flow

## Summary
